// This file is generated by rust-protobuf 2.0.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Pointer {
    // message fields
    pub partition_key: u32,
    pub filename: u32,
    pub offset: u64,
    pub length: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Pointer {
    pub fn new() -> Pointer {
        ::std::default::Default::default()
    }

    // fixed32 partition_key = 1;

    pub fn clear_partition_key(&mut self) {
        self.partition_key = 0;
    }

    // Param is passed by value, moved
    pub fn set_partition_key(&mut self, v: u32) {
        self.partition_key = v;
    }

    pub fn get_partition_key(&self) -> u32 {
        self.partition_key
    }

    // fixed32 filename = 2;

    pub fn clear_filename(&mut self) {
        self.filename = 0;
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: u32) {
        self.filename = v;
    }

    pub fn get_filename(&self) -> u32 {
        self.filename
    }

    // fixed64 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = v;
    }

    pub fn get_offset(&self) -> u64 {
        self.offset
    }

    // fixed64 length = 4;

    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = v;
    }

    pub fn get_length(&self) -> u64 {
        self.length
    }
}

impl ::protobuf::Message for Pointer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.partition_key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.filename = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.offset = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.length = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.partition_key != 0 {
            my_size += 5;
        }
        if self.filename != 0 {
            my_size += 5;
        }
        if self.offset != 0 {
            my_size += 9;
        }
        if self.length != 0 {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.partition_key != 0 {
            os.write_fixed32(1, self.partition_key)?;
        }
        if self.filename != 0 {
            os.write_fixed32(2, self.filename)?;
        }
        if self.offset != 0 {
            os.write_fixed64(3, self.offset)?;
        }
        if self.length != 0 {
            os.write_fixed64(4, self.length)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pointer {
        Pointer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "partition_key",
                    |m: &Pointer| { &m.partition_key },
                    |m: &mut Pointer| { &mut m.partition_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                    "filename",
                    |m: &Pointer| { &m.filename },
                    |m: &mut Pointer| { &mut m.filename },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "offset",
                    |m: &Pointer| { &m.offset },
                    |m: &mut Pointer| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                    "length",
                    |m: &Pointer| { &m.length },
                    |m: &mut Pointer| { &mut m.length },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Pointer>(
                    "Pointer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Pointer {
        static mut instance: ::protobuf::lazy::Lazy<Pointer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pointer,
        };
        unsafe {
            instance.get(Pointer::new)
        }
    }
}

impl ::protobuf::Clear for Pointer {
    fn clear(&mut self) {
        self.clear_partition_key();
        self.clear_filename();
        self.clear_offset();
        self.clear_length();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pointer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pointer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeBytes {
    // message fields
    pub field_type: ::protobuf::Chars,
    pub bytes: ::bytes::Bytes,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TypeBytes {
    pub fn new() -> TypeBytes {
        ::std::default::Default::default()
    }

    // string type = 1;

    pub fn clear_field_type(&mut self) {
        ::protobuf::Clear::clear(&mut self.field_type);
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::protobuf::Chars) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::protobuf::Chars {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.field_type, ::protobuf::Chars::new())
    }

    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }

    // bytes bytes = 2;

    pub fn clear_bytes(&mut self) {
        self.bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::bytes::Bytes) {
        self.bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::bytes::Bytes {
        &mut self.bytes
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.bytes, ::bytes::Bytes::new())
    }

    pub fn get_bytes(&self) -> &[u8] {
        &self.bytes
    }
}

impl ::protobuf::Message for TypeBytes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        if !self.bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        if !self.bytes.is_empty() {
            os.write_bytes(2, &self.bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeBytes {
        TypeBytes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "type",
                    |m: &TypeBytes| { &m.field_type },
                    |m: &mut TypeBytes| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "bytes",
                    |m: &TypeBytes| { &m.bytes },
                    |m: &mut TypeBytes| { &mut m.bytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeBytes>(
                    "TypeBytes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeBytes {
        static mut instance: ::protobuf::lazy::Lazy<TypeBytes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeBytes,
        };
        unsafe {
            instance.get(TypeBytes::new)
        }
    }
}

impl ::protobuf::Clear for TypeBytes {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_bytes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeBytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeBytes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeID {
    // message fields
    pub graph: ::protobuf::Chars,
    pub nodeid: ::protobuf::Chars,
    pub node_pointer: ::protobuf::SingularPtrField<Pointer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NodeID {
    pub fn new() -> NodeID {
        ::std::default::Default::default()
    }

    // string graph = 1;

    pub fn clear_graph(&mut self) {
        ::protobuf::Clear::clear(&mut self.graph);
    }

    // Param is passed by value, moved
    pub fn set_graph(&mut self, v: ::protobuf::Chars) {
        self.graph = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph(&mut self) -> &mut ::protobuf::Chars {
        &mut self.graph
    }

    // Take field
    pub fn take_graph(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.graph, ::protobuf::Chars::new())
    }

    pub fn get_graph(&self) -> &str {
        &self.graph
    }

    // string nodeid = 2;

    pub fn clear_nodeid(&mut self) {
        ::protobuf::Clear::clear(&mut self.nodeid);
    }

    // Param is passed by value, moved
    pub fn set_nodeid(&mut self, v: ::protobuf::Chars) {
        self.nodeid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeid(&mut self) -> &mut ::protobuf::Chars {
        &mut self.nodeid
    }

    // Take field
    pub fn take_nodeid(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.nodeid, ::protobuf::Chars::new())
    }

    pub fn get_nodeid(&self) -> &str {
        &self.nodeid
    }

    // .ahghee.grpc.Pointer node_pointer = 3;

    pub fn clear_node_pointer(&mut self) {
        self.node_pointer.clear();
    }

    pub fn has_node_pointer(&self) -> bool {
        self.node_pointer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_pointer(&mut self, v: Pointer) {
        self.node_pointer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pointer(&mut self) -> &mut Pointer {
        if self.node_pointer.is_none() {
            self.node_pointer.set_default();
        }
        self.node_pointer.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_pointer(&mut self) -> Pointer {
        self.node_pointer.take().unwrap_or_else(|| Pointer::new())
    }

    pub fn get_node_pointer(&self) -> &Pointer {
        self.node_pointer.as_ref().unwrap_or_else(|| Pointer::default_instance())
    }
}

impl ::protobuf::Message for NodeID {
    fn is_initialized(&self) -> bool {
        for v in &self.node_pointer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.graph)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.nodeid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node_pointer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.graph.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph);
        }
        if !self.nodeid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.nodeid);
        }
        if let Some(ref v) = self.node_pointer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.graph.is_empty() {
            os.write_string(1, &self.graph)?;
        }
        if !self.nodeid.is_empty() {
            os.write_string(2, &self.nodeid)?;
        }
        if let Some(ref v) = self.node_pointer.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeID {
        NodeID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "graph",
                    |m: &NodeID| { &m.graph },
                    |m: &mut NodeID| { &mut m.graph },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "nodeid",
                    |m: &NodeID| { &m.nodeid },
                    |m: &mut NodeID| { &mut m.nodeid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pointer>>(
                    "node_pointer",
                    |m: &NodeID| { &m.node_pointer },
                    |m: &mut NodeID| { &mut m.node_pointer },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeID>(
                    "NodeID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeID {
        static mut instance: ::protobuf::lazy::Lazy<NodeID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeID,
        };
        unsafe {
            instance.get(NodeID::new)
        }
    }
}

impl ::protobuf::Clear for NodeID {
    fn clear(&mut self) {
        self.clear_graph();
        self.clear_nodeid();
        self.clear_node_pointer();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalNodeID {
    // message fields
    pub domain: ::protobuf::Chars,
    pub database: ::protobuf::Chars,
    pub nodeid: ::protobuf::SingularPtrField<NodeID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GlobalNodeID {
    pub fn new() -> GlobalNodeID {
        ::std::default::Default::default()
    }

    // string domain = 1;

    pub fn clear_domain(&mut self) {
        ::protobuf::Clear::clear(&mut self.domain);
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::protobuf::Chars) {
        self.domain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::protobuf::Chars {
        &mut self.domain
    }

    // Take field
    pub fn take_domain(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.domain, ::protobuf::Chars::new())
    }

    pub fn get_domain(&self) -> &str {
        &self.domain
    }

    // string database = 2;

    pub fn clear_database(&mut self) {
        ::protobuf::Clear::clear(&mut self.database);
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::protobuf::Chars) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::protobuf::Chars {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::protobuf::Chars {
        ::std::mem::replace(&mut self.database, ::protobuf::Chars::new())
    }

    pub fn get_database(&self) -> &str {
        &self.database
    }

    // .ahghee.grpc.NodeID nodeid = 3;

    pub fn clear_nodeid(&mut self) {
        self.nodeid.clear();
    }

    pub fn has_nodeid(&self) -> bool {
        self.nodeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeid(&mut self, v: NodeID) {
        self.nodeid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeid(&mut self) -> &mut NodeID {
        if self.nodeid.is_none() {
            self.nodeid.set_default();
        }
        self.nodeid.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeid(&mut self) -> NodeID {
        self.nodeid.take().unwrap_or_else(|| NodeID::new())
    }

    pub fn get_nodeid(&self) -> &NodeID {
        self.nodeid.as_ref().unwrap_or_else(|| NodeID::default_instance())
    }
}

impl ::protobuf::Message for GlobalNodeID {
    fn is_initialized(&self) -> bool {
        for v in &self.nodeid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.domain)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_string_into(wire_type, is, &mut self.database)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nodeid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.domain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.domain);
        }
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.database);
        }
        if let Some(ref v) = self.nodeid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.domain.is_empty() {
            os.write_string(1, &self.domain)?;
        }
        if !self.database.is_empty() {
            os.write_string(2, &self.database)?;
        }
        if let Some(ref v) = self.nodeid.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalNodeID {
        GlobalNodeID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "domain",
                    |m: &GlobalNodeID| { &m.domain },
                    |m: &mut GlobalNodeID| { &mut m.domain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheChars>(
                    "database",
                    |m: &GlobalNodeID| { &m.database },
                    |m: &mut GlobalNodeID| { &mut m.database },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeID>>(
                    "nodeid",
                    |m: &GlobalNodeID| { &m.nodeid },
                    |m: &mut GlobalNodeID| { &mut m.nodeid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GlobalNodeID>(
                    "GlobalNodeID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GlobalNodeID {
        static mut instance: ::protobuf::lazy::Lazy<GlobalNodeID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GlobalNodeID,
        };
        unsafe {
            instance.get(GlobalNodeID::new)
        }
    }
}

impl ::protobuf::Clear for GlobalNodeID {
    fn clear(&mut self) {
        self.clear_domain();
        self.clear_database();
        self.clear_nodeid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalNodeID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalNodeID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Data {
    // message oneof groups
    pub block: ::std::option::Option<Data_oneof_block>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Data_oneof_block {
    node_id(NodeID),
    global_node_id(GlobalNodeID),
    type_bytes(TypeBytes),
    bytes_pointer(Pointer),
}

impl Data {
    pub fn new() -> Data {
        ::std::default::Default::default()
    }

    // .ahghee.grpc.NodeID node_id = 1;

    pub fn clear_node_id(&mut self) {
        self.block = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::node_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: NodeID) {
        self.block = ::std::option::Option::Some(Data_oneof_block::node_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_node_id(&mut self) -> &mut NodeID {
        if let ::std::option::Option::Some(Data_oneof_block::node_id(_)) = self.block {
        } else {
            self.block = ::std::option::Option::Some(Data_oneof_block::node_id(NodeID::new()));
        }
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::node_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_node_id(&mut self) -> NodeID {
        if self.has_node_id() {
            match self.block.take() {
                ::std::option::Option::Some(Data_oneof_block::node_id(v)) => v,
                _ => panic!(),
            }
        } else {
            NodeID::new()
        }
    }

    pub fn get_node_id(&self) -> &NodeID {
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::node_id(ref v)) => v,
            _ => NodeID::default_instance(),
        }
    }

    // .ahghee.grpc.GlobalNodeID global_node_id = 2;

    pub fn clear_global_node_id(&mut self) {
        self.block = ::std::option::Option::None;
    }

    pub fn has_global_node_id(&self) -> bool {
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::global_node_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_global_node_id(&mut self, v: GlobalNodeID) {
        self.block = ::std::option::Option::Some(Data_oneof_block::global_node_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_global_node_id(&mut self) -> &mut GlobalNodeID {
        if let ::std::option::Option::Some(Data_oneof_block::global_node_id(_)) = self.block {
        } else {
            self.block = ::std::option::Option::Some(Data_oneof_block::global_node_id(GlobalNodeID::new()));
        }
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::global_node_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_global_node_id(&mut self) -> GlobalNodeID {
        if self.has_global_node_id() {
            match self.block.take() {
                ::std::option::Option::Some(Data_oneof_block::global_node_id(v)) => v,
                _ => panic!(),
            }
        } else {
            GlobalNodeID::new()
        }
    }

    pub fn get_global_node_id(&self) -> &GlobalNodeID {
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::global_node_id(ref v)) => v,
            _ => GlobalNodeID::default_instance(),
        }
    }

    // .ahghee.grpc.TypeBytes type_bytes = 3;

    pub fn clear_type_bytes(&mut self) {
        self.block = ::std::option::Option::None;
    }

    pub fn has_type_bytes(&self) -> bool {
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::type_bytes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_bytes(&mut self, v: TypeBytes) {
        self.block = ::std::option::Option::Some(Data_oneof_block::type_bytes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_bytes(&mut self) -> &mut TypeBytes {
        if let ::std::option::Option::Some(Data_oneof_block::type_bytes(_)) = self.block {
        } else {
            self.block = ::std::option::Option::Some(Data_oneof_block::type_bytes(TypeBytes::new()));
        }
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::type_bytes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_bytes(&mut self) -> TypeBytes {
        if self.has_type_bytes() {
            match self.block.take() {
                ::std::option::Option::Some(Data_oneof_block::type_bytes(v)) => v,
                _ => panic!(),
            }
        } else {
            TypeBytes::new()
        }
    }

    pub fn get_type_bytes(&self) -> &TypeBytes {
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::type_bytes(ref v)) => v,
            _ => TypeBytes::default_instance(),
        }
    }

    // .ahghee.grpc.Pointer bytes_pointer = 4;

    pub fn clear_bytes_pointer(&mut self) {
        self.block = ::std::option::Option::None;
    }

    pub fn has_bytes_pointer(&self) -> bool {
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::bytes_pointer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bytes_pointer(&mut self, v: Pointer) {
        self.block = ::std::option::Option::Some(Data_oneof_block::bytes_pointer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bytes_pointer(&mut self) -> &mut Pointer {
        if let ::std::option::Option::Some(Data_oneof_block::bytes_pointer(_)) = self.block {
        } else {
            self.block = ::std::option::Option::Some(Data_oneof_block::bytes_pointer(Pointer::new()));
        }
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::bytes_pointer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bytes_pointer(&mut self) -> Pointer {
        if self.has_bytes_pointer() {
            match self.block.take() {
                ::std::option::Option::Some(Data_oneof_block::bytes_pointer(v)) => v,
                _ => panic!(),
            }
        } else {
            Pointer::new()
        }
    }

    pub fn get_bytes_pointer(&self) -> &Pointer {
        match self.block {
            ::std::option::Option::Some(Data_oneof_block::bytes_pointer(ref v)) => v,
            _ => Pointer::default_instance(),
        }
    }
}

impl ::protobuf::Message for Data {
    fn is_initialized(&self) -> bool {
        if let Some(Data_oneof_block::node_id(ref v)) = self.block {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Data_oneof_block::global_node_id(ref v)) = self.block {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Data_oneof_block::type_bytes(ref v)) = self.block {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Data_oneof_block::bytes_pointer(ref v)) = self.block {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.block = ::std::option::Option::Some(Data_oneof_block::node_id(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.block = ::std::option::Option::Some(Data_oneof_block::global_node_id(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.block = ::std::option::Option::Some(Data_oneof_block::type_bytes(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.block = ::std::option::Option::Some(Data_oneof_block::bytes_pointer(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.block {
            match v {
                &Data_oneof_block::node_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Data_oneof_block::global_node_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Data_oneof_block::type_bytes(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Data_oneof_block::bytes_pointer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.block {
            match v {
                &Data_oneof_block::node_id(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Data_oneof_block::global_node_id(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Data_oneof_block::type_bytes(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Data_oneof_block::bytes_pointer(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Data {
        Data::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, NodeID>(
                    "node_id",
                    Data::has_node_id,
                    Data::get_node_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GlobalNodeID>(
                    "global_node_id",
                    Data::has_global_node_id,
                    Data::get_global_node_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TypeBytes>(
                    "type_bytes",
                    Data::has_type_bytes,
                    Data::get_type_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Pointer>(
                    "bytes_pointer",
                    Data::has_bytes_pointer,
                    Data::get_bytes_pointer,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Data>(
                    "Data",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Data {
        static mut instance: ::protobuf::lazy::Lazy<Data> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Data,
        };
        unsafe {
            instance.get(Data::new)
        }
    }
}

impl ::protobuf::Clear for Data {
    fn clear(&mut self) {
        self.clear_node_id();
        self.clear_global_node_id();
        self.clear_type_bytes();
        self.clear_bytes_pointer();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Data {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Data {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddressBlock {
    // message oneof groups
    pub address: ::std::option::Option<AddressBlock_oneof_address>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum AddressBlock_oneof_address {
    node_id(NodeID),
    global_node_id(GlobalNodeID),
}

impl AddressBlock {
    pub fn new() -> AddressBlock {
        ::std::default::Default::default()
    }

    // .ahghee.grpc.NodeID node_id = 1;

    pub fn clear_node_id(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        match self.address {
            ::std::option::Option::Some(AddressBlock_oneof_address::node_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: NodeID) {
        self.address = ::std::option::Option::Some(AddressBlock_oneof_address::node_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_node_id(&mut self) -> &mut NodeID {
        if let ::std::option::Option::Some(AddressBlock_oneof_address::node_id(_)) = self.address {
        } else {
            self.address = ::std::option::Option::Some(AddressBlock_oneof_address::node_id(NodeID::new()));
        }
        match self.address {
            ::std::option::Option::Some(AddressBlock_oneof_address::node_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_node_id(&mut self) -> NodeID {
        if self.has_node_id() {
            match self.address.take() {
                ::std::option::Option::Some(AddressBlock_oneof_address::node_id(v)) => v,
                _ => panic!(),
            }
        } else {
            NodeID::new()
        }
    }

    pub fn get_node_id(&self) -> &NodeID {
        match self.address {
            ::std::option::Option::Some(AddressBlock_oneof_address::node_id(ref v)) => v,
            _ => NodeID::default_instance(),
        }
    }

    // .ahghee.grpc.GlobalNodeID global_node_id = 2;

    pub fn clear_global_node_id(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_global_node_id(&self) -> bool {
        match self.address {
            ::std::option::Option::Some(AddressBlock_oneof_address::global_node_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_global_node_id(&mut self, v: GlobalNodeID) {
        self.address = ::std::option::Option::Some(AddressBlock_oneof_address::global_node_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_global_node_id(&mut self) -> &mut GlobalNodeID {
        if let ::std::option::Option::Some(AddressBlock_oneof_address::global_node_id(_)) = self.address {
        } else {
            self.address = ::std::option::Option::Some(AddressBlock_oneof_address::global_node_id(GlobalNodeID::new()));
        }
        match self.address {
            ::std::option::Option::Some(AddressBlock_oneof_address::global_node_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_global_node_id(&mut self) -> GlobalNodeID {
        if self.has_global_node_id() {
            match self.address.take() {
                ::std::option::Option::Some(AddressBlock_oneof_address::global_node_id(v)) => v,
                _ => panic!(),
            }
        } else {
            GlobalNodeID::new()
        }
    }

    pub fn get_global_node_id(&self) -> &GlobalNodeID {
        match self.address {
            ::std::option::Option::Some(AddressBlock_oneof_address::global_node_id(ref v)) => v,
            _ => GlobalNodeID::default_instance(),
        }
    }
}

impl ::protobuf::Message for AddressBlock {
    fn is_initialized(&self) -> bool {
        if let Some(AddressBlock_oneof_address::node_id(ref v)) = self.address {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(AddressBlock_oneof_address::global_node_id(ref v)) = self.address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.address = ::std::option::Option::Some(AddressBlock_oneof_address::node_id(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.address = ::std::option::Option::Some(AddressBlock_oneof_address::global_node_id(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.address {
            match v {
                &AddressBlock_oneof_address::node_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AddressBlock_oneof_address::global_node_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.address {
            match v {
                &AddressBlock_oneof_address::node_id(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AddressBlock_oneof_address::global_node_id(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressBlock {
        AddressBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, NodeID>(
                    "node_id",
                    AddressBlock::has_node_id,
                    AddressBlock::get_node_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GlobalNodeID>(
                    "global_node_id",
                    AddressBlock::has_global_node_id,
                    AddressBlock::get_global_node_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddressBlock>(
                    "AddressBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddressBlock {
        static mut instance: ::protobuf::lazy::Lazy<AddressBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddressBlock,
        };
        unsafe {
            instance.get(AddressBlock::new)
        }
    }
}

impl ::protobuf::Clear for AddressBlock {
    fn clear(&mut self) {
        self.clear_node_id();
        self.clear_global_node_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TMD {
    // message fields
    pub time_stamp: u64,
    pub meta_data: ::protobuf::SingularPtrField<Data>,
    pub data: ::protobuf::SingularPtrField<Data>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TMD {
    pub fn new() -> TMD {
        ::std::default::Default::default()
    }

    // uint64 time_stamp = 1;

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = v;
    }

    pub fn get_time_stamp(&self) -> u64 {
        self.time_stamp
    }

    // .ahghee.grpc.Data meta_data = 2;

    pub fn clear_meta_data(&mut self) {
        self.meta_data.clear();
    }

    pub fn has_meta_data(&self) -> bool {
        self.meta_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data(&mut self, v: Data) {
        self.meta_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_meta_data(&mut self) -> &mut Data {
        if self.meta_data.is_none() {
            self.meta_data.set_default();
        }
        self.meta_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_meta_data(&mut self) -> Data {
        self.meta_data.take().unwrap_or_else(|| Data::new())
    }

    pub fn get_meta_data(&self) -> &Data {
        self.meta_data.as_ref().unwrap_or_else(|| Data::default_instance())
    }

    // .ahghee.grpc.Data data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Data {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        self.data.take().unwrap_or_else(|| Data::new())
    }

    pub fn get_data(&self) -> &Data {
        self.data.as_ref().unwrap_or_else(|| Data::default_instance())
    }
}

impl ::protobuf::Message for TMD {
    fn is_initialized(&self) -> bool {
        for v in &self.meta_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.time_stamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.meta_data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time_stamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time_stamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.meta_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.time_stamp != 0 {
            os.write_uint64(1, self.time_stamp)?;
        }
        if let Some(ref v) = self.meta_data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TMD {
        TMD::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "time_stamp",
                    |m: &TMD| { &m.time_stamp },
                    |m: &mut TMD| { &mut m.time_stamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                    "meta_data",
                    |m: &TMD| { &m.meta_data },
                    |m: &mut TMD| { &mut m.meta_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                    "data",
                    |m: &TMD| { &m.data },
                    |m: &mut TMD| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TMD>(
                    "TMD",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TMD {
        static mut instance: ::protobuf::lazy::Lazy<TMD> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TMD,
        };
        unsafe {
            instance.get(TMD::new)
        }
    }
}

impl ::protobuf::Clear for TMD {
    fn clear(&mut self) {
        self.clear_time_stamp();
        self.clear_meta_data();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TMD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TMD {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyValue {
    // message fields
    pub key: ::protobuf::SingularPtrField<TMD>,
    pub value: ::protobuf::SingularPtrField<TMD>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl KeyValue {
    pub fn new() -> KeyValue {
        ::std::default::Default::default()
    }

    // .ahghee.grpc.TMD key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: TMD) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut TMD {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> TMD {
        self.key.take().unwrap_or_else(|| TMD::new())
    }

    pub fn get_key(&self) -> &TMD {
        self.key.as_ref().unwrap_or_else(|| TMD::default_instance())
    }

    // .ahghee.grpc.TMD value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TMD) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut TMD {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> TMD {
        self.value.take().unwrap_or_else(|| TMD::new())
    }

    pub fn get_value(&self) -> &TMD {
        self.value.as_ref().unwrap_or_else(|| TMD::default_instance())
    }
}

impl ::protobuf::Message for KeyValue {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyValue {
        KeyValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TMD>>(
                    "key",
                    |m: &KeyValue| { &m.key },
                    |m: &mut KeyValue| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TMD>>(
                    "value",
                    |m: &KeyValue| { &m.value },
                    |m: &mut KeyValue| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyValue>(
                    "KeyValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyValue {
        static mut instance: ::protobuf::lazy::Lazy<KeyValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyValue,
        };
        unsafe {
            instance.get(KeyValue::new)
        }
    }
}

impl ::protobuf::Clear for KeyValue {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Node {
    // message fields
    pub id: ::protobuf::SingularPtrField<AddressBlock>,
    pub fragments: ::protobuf::RepeatedField<Pointer>,
    pub attributes: ::protobuf::RepeatedField<KeyValue>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // .ahghee.grpc.AddressBlock id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: AddressBlock) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut AddressBlock {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> AddressBlock {
        self.id.take().unwrap_or_else(|| AddressBlock::new())
    }

    pub fn get_id(&self) -> &AddressBlock {
        self.id.as_ref().unwrap_or_else(|| AddressBlock::default_instance())
    }

    // repeated .ahghee.grpc.Pointer fragments = 2;

    pub fn clear_fragments(&mut self) {
        self.fragments.clear();
    }

    // Param is passed by value, moved
    pub fn set_fragments(&mut self, v: ::protobuf::RepeatedField<Pointer>) {
        self.fragments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fragments(&mut self) -> &mut ::protobuf::RepeatedField<Pointer> {
        &mut self.fragments
    }

    // Take field
    pub fn take_fragments(&mut self) -> ::protobuf::RepeatedField<Pointer> {
        ::std::mem::replace(&mut self.fragments, ::protobuf::RepeatedField::new())
    }

    pub fn get_fragments(&self) -> &[Pointer] {
        &self.fragments
    }

    // repeated .ahghee.grpc.KeyValue attributes = 3;

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    pub fn get_attributes(&self) -> &[KeyValue] {
        &self.attributes
    }
}

impl ::protobuf::Message for Node {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fragments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fragments)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.fragments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.fragments {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.attributes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Node {
        Node::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressBlock>>(
                    "id",
                    |m: &Node| { &m.id },
                    |m: &mut Node| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pointer>>(
                    "fragments",
                    |m: &Node| { &m.fragments },
                    |m: &mut Node| { &mut m.fragments },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValue>>(
                    "attributes",
                    |m: &Node| { &m.attributes },
                    |m: &mut Node| { &mut m.attributes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Node>(
                    "Node",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Node {
        static mut instance: ::protobuf::lazy::Lazy<Node> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Node,
        };
        unsafe {
            instance.get(Node::new)
        }
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_fragments();
        self.clear_attributes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pointers {
    // message fields
    pub pointers: ::protobuf::RepeatedField<Pointer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Pointers {
    pub fn new() -> Pointers {
        ::std::default::Default::default()
    }

    // repeated .ahghee.grpc.Pointer pointers = 1;

    pub fn clear_pointers(&mut self) {
        self.pointers.clear();
    }

    // Param is passed by value, moved
    pub fn set_pointers(&mut self, v: ::protobuf::RepeatedField<Pointer>) {
        self.pointers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pointers(&mut self) -> &mut ::protobuf::RepeatedField<Pointer> {
        &mut self.pointers
    }

    // Take field
    pub fn take_pointers(&mut self) -> ::protobuf::RepeatedField<Pointer> {
        ::std::mem::replace(&mut self.pointers, ::protobuf::RepeatedField::new())
    }

    pub fn get_pointers(&self) -> &[Pointer] {
        &self.pointers
    }
}

impl ::protobuf::Message for Pointers {
    fn is_initialized(&self) -> bool {
        for v in &self.pointers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pointers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pointers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pointers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pointers {
        Pointers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pointer>>(
                    "pointers",
                    |m: &Pointers| { &m.pointers },
                    |m: &mut Pointers| { &mut m.pointers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Pointers>(
                    "Pointers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Pointers {
        static mut instance: ::protobuf::lazy::Lazy<Pointers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pointers,
        };
        unsafe {
            instance.get(Pointers::new)
        }
    }
}

impl ::protobuf::Clear for Pointers {
    fn clear(&mut self) {
        self.clear_pointers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pointers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pointers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0btypes.proto\x12\x0bahghee.grpc\"z\n\x07Pointer\x12#\n\rpartition_k\
    ey\x18\x01\x20\x01(\x07R\x0cpartitionKey\x12\x1a\n\x08filename\x18\x02\
    \x20\x01(\x07R\x08filename\x12\x16\n\x06offset\x18\x03\x20\x01(\x06R\x06\
    offset\x12\x16\n\x06length\x18\x04\x20\x01(\x06R\x06length\"5\n\tTypeByt\
    es\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x14\n\x05bytes\x18\
    \x02\x20\x01(\x0cR\x05bytes\"o\n\x06NodeID\x12\x14\n\x05graph\x18\x01\
    \x20\x01(\tR\x05graph\x12\x16\n\x06nodeid\x18\x02\x20\x01(\tR\x06nodeid\
    \x127\n\x0cnode_pointer\x18\x03\x20\x01(\x0b2\x14.ahghee.grpc.PointerR\
    \x0bnodePointer\"o\n\x0cGlobalNodeID\x12\x16\n\x06domain\x18\x01\x20\x01\
    (\tR\x06domain\x12\x1a\n\x08database\x18\x02\x20\x01(\tR\x08database\x12\
    +\n\x06nodeid\x18\x03\x20\x01(\x0b2\x13.ahghee.grpc.NodeIDR\x06nodeid\"\
    \xf8\x01\n\x04Data\x12.\n\x07node_id\x18\x01\x20\x01(\x0b2\x13.ahghee.gr\
    pc.NodeIDH\0R\x06nodeId\x12A\n\x0eglobal_node_id\x18\x02\x20\x01(\x0b2\
    \x19.ahghee.grpc.GlobalNodeIDH\0R\x0cglobalNodeId\x127\n\ntype_bytes\x18\
    \x03\x20\x01(\x0b2\x16.ahghee.grpc.TypeBytesH\0R\ttypeBytes\x12;\n\rbyte\
    s_pointer\x18\x04\x20\x01(\x0b2\x14.ahghee.grpc.PointerH\0R\x0cbytesPoin\
    terB\x07\n\x05block\"\x8c\x01\n\x0cAddressBlock\x12.\n\x07node_id\x18\
    \x01\x20\x01(\x0b2\x13.ahghee.grpc.NodeIDH\0R\x06nodeId\x12A\n\x0eglobal\
    _node_id\x18\x02\x20\x01(\x0b2\x19.ahghee.grpc.GlobalNodeIDH\0R\x0cgloba\
    lNodeIdB\t\n\x07address\"{\n\x03TMD\x12\x1d\n\ntime_stamp\x18\x01\x20\
    \x01(\x04R\ttimeStamp\x12.\n\tmeta_data\x18\x02\x20\x01(\x0b2\x11.ahghee\
    .grpc.DataR\x08metaData\x12%\n\x04data\x18\x03\x20\x01(\x0b2\x11.ahghee.\
    grpc.DataR\x04data\"V\n\x08KeyValue\x12\"\n\x03key\x18\x01\x20\x01(\x0b2\
    \x10.ahghee.grpc.TMDR\x03key\x12&\n\x05value\x18\x02\x20\x01(\x0b2\x10.a\
    hghee.grpc.TMDR\x05value\"\x9c\x01\n\x04Node\x12)\n\x02id\x18\x01\x20\
    \x01(\x0b2\x19.ahghee.grpc.AddressBlockR\x02id\x122\n\tfragments\x18\x02\
    \x20\x03(\x0b2\x14.ahghee.grpc.PointerR\tfragments\x125\n\nattributes\
    \x18\x03\x20\x03(\x0b2\x15.ahghee.grpc.KeyValueR\nattributes\"<\n\x08Poi\
    nters\x120\n\x08pointers\x18\x01\x20\x03(\x0b2\x14.ahghee.grpc.PointerR\
    \x08pointersb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
