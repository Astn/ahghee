@using Ahghee.Grpc
@using FASTER.core
@inject IJSRuntime JSRuntime;



<svg id="@uniqueId" @ref="d3Container" style="overflow: hidden;" xmlns="http://www.w3.org/2000/svg"></svg>



@code {
    [Parameter]
    public List<Node> Nodes { get; set; }

    private int lasthash = 0;
    private ElementReference d3Container;
    private string uniqueId = Guid.NewGuid().ToString().Replace("-", "");
    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        
        // tod: like should we render?
        // be great to know if the nodes we have now are different from the nodes we had last time.
        var newHash = Nodes.Select(n => n.Id.Iri.GetHashCode()).Aggregate(0, (acc, next) => acc ^ next);
        if (newHash != lasthash)
        {
            lasthash = newHash;
            DoIt();
        }
        //this.StateHasChanged();
    }

    protected override Task OnInitializedAsync()
    {
        return base.OnInitializedAsync();
    }

    public async Task DoIt()
    {
        // we dont' want to send extra junk down.
        // filter to only attributes that are edges.
        Console.WriteLine("cleaning it");
        var lessData =  Nodes.Select(n =>
        {
            var nn = new Node();
            nn.MergeFrom(n);
            nn.Fragments.Clear();
            var edges = nn.Attributes.Where(a => a.Value.Data.Nodeid!=null).ToList();
            nn.Attributes.Clear();
            nn.Attributes.AddRange(edges);
            return nn;
        });
        Console.WriteLine("cleaning it - finished, rendering");
        await JSRuntime.InvokeVoidAsync(
            "d3Interop.renderGraph", uniqueId, lessData);
        Console.WriteLine("RenderGraph - finished");
    }
    
}